package net.nicoptere{	import net.nicoptere.Point2D;		//Credit to Paul Bourke (pbourke@swin.edu.au) for the original Fortran 77 Program :))	//Converted to a standalone C# 2.0 library by Morten Nielsen (www.iter.dk)	//Check out: http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/	//You can use this code however you like providing the above credits remain in tact	/// <summary>	/// Performs the Delauney triangulation on a set of vertices.	/// </summary>	/// <remarks>	/// Based on Paul Bourke's "An Algorithm for Interpolating Irregularly-Spaced Data	/// with Applications in Terrain Modelling"	/// http://astronomy.swin.edu.au/~pbourke/modelling/triangulate/	/// </remarks>	public class Delaunay		{		/// <summary>		/// Performs Delauney triangulation on a set of points.		/// </summary>		/// <remarks>		/// <para>		/// The triangulation doesn't support multiple points with the same planar location.		/// Vertex-lists with duplicate points may result in strange triangulation with intersecting edges.		/// To avoid adding multiple points to your vertex-list you can use the following anonymous predicate		/// method:		/// <code>		/// if(!Vertices.Exists(delegate(Triangulator.Geometry.Point2D p) { return pNew.equals2D(p); }))		///		Vertices.Add(pNew);		/// </code>		/// </para>		/// <para>The triangulation algorithm may be described in pseudo-code as follows:		/// <code>		/// subroutine Triangulate		/// input : vertex list		/// output : triangle list		///    initialize the triangle list		///    determine the supertriangle		///    add supertriangle vertices to the end of the vertex list		///    add the supertriangle to the triangle list		///    for each sample point in the vertex list		///       initialize the edge buffer		///       for each triangle currently in the triangle list		///          calculate the triangle circumcircle center and radius		///          if the point lies in the triangle circumcircle then		///             add the three triangle edges to the edge buffer		///             remove the triangle from the triangle list		///          endif		///       endfor		///       delete all doubly specified edges from the edge buffer		///          this leaves the edges of the enclosing polygon only		///       add to the triangle list all triangles formed between the point 		///          and the edges of the enclosing polygon		///    endfor		///    remove any triangles from the triangle list that use the supertriangle vertices		///    remove the supertriangle vertices from the vertex list		/// end		/// </code>		/// </para>		/// </remarks>		/// <param name="Vertex">List of vertices to triangulate.</param>		/// <returns>Triangles referencing vertex indices arranged in clockwise order</returns>		public static function Triangulate(Vertex:Array):Array		{			var nv:int = Vertex.length;			if (nv < 3) return [];			var trimax:int = 4 * nv;			// Find the maximum and minimum vertex bounds.			// This is to allow calculation of the bounding supertriangle			var xmin:Number = Vertex[0].X;			var ymin:Number = Vertex[0].Y;			var xmax:Number = xmin;			var ymax:Number = ymin;			for (var i:int = 1; i < nv; i++)			{				(Vertex[i] as Point2D).id = i;					// use Math.min and Math.max?								if (Vertex[i].X < xmin) xmin = Vertex[i].X;				if (Vertex[i].X > xmax) xmax = Vertex[i].X;				if (Vertex[i].Y < ymin) ymin = Vertex[i].Y;				if (Vertex[i].Y > ymax) ymax = Vertex[i].Y;			}						var dx:Number = xmax - xmin;			var dy:Number = ymax - ymin;			var dmax:Number = (dx > dy) ? dx : dy;			var xmid:Number = (xmax + xmin) * 0.5;			var ymid:Number = (ymax + ymin) * 0.5;			// Set up the supertriangle			// This is a triangle which encompasses all the sample points.			// The supertriangle coordinates are added to the end of the			// vertex list. The supertriangle is the first triangle in			// the triangle list.			Vertex.push(new Point2D((xmid - 2 * dmax), (ymid - dmax), nv+1));			Vertex.push(new Point2D(xmid, (ymid + 2 * dmax), nv+2));			Vertex.push(new Point2D((xmid + 2 * dmax), (ymid - dmax), nv+3));			var Triangles:Array = new Array();//array typ√© de triangles			Triangles.push( new Triangle( Vertex[ nv ], Vertex[ nv + 1 ], Vertex[ nv + 2 ] ) ); //SuperTriangle placed at index 0			// Include each point one at a time into the existing mesh			for ( i = 0; i < nv; i++)			{							var Edges:Array = new Array(); //[trimax * 3];				// Set up the edge buffer.				// If the point (Vertex(i).x,Vertex(i).y) lies inside the circumcircle then the				// three edges of that triangle are added to the edge buffer and the triangle is removed from list.				for (var j:int = 0; j < Triangles.length; j++ )				{					if ( InCircle( Vertex[ i ], Triangles[ j ].p1, Triangles[ j ].p2, Triangles[ j ].p3 ) )					{						Edges.push(new Edge(Triangles[j].p1, Triangles[j].p2) );						Edges.push(new Edge(Triangles[j].p2, Triangles[j].p3) );						Edges.push(new Edge(Triangles[j].p3, Triangles[j].p1) );						Triangles.splice( j,1 );						j--;					}				}				if ( i >= nv) continue; //In case we the last duplicate point we removed was the last in the array				// Remove duplicate edges				// Note: if all triangles are specified anticlockwise then all				// interior edges are opposite pointing in direction.				for ( j = Edges.length - 2; j >= 0; j--)				{					for (var k:int = Edges.length - 1; k >= j + 1; k--)					{						if ( Edges[ j ].equals( Edges[ k ] ) )						{							Edges.splice( k, 1 );							Edges.splice( j, 1 );							k--;							continue;						}					}				}				// Form new triangles for the current point				// Skipping over any tagged edges.				// All edges are arranged in clockwise order.				for ( j = 0; j < Edges.length; j++)				{					if (Triangles.length >= trimax)					{						//	throw new ApplicationException("Exceeded maximum edges");						trace("Exceeded maximum edges");					}					Triangles.push( new Triangle( Edges[ j ].p1, Edges[ j ].p2, Vertex[ i ] ));				}				Edges = [];							}						// Remove triangles with supertriangle vertices			// These are triangles which have a vertex number greater than nv			for ( i = Triangles.length - 1; i >= 0; i--)			{				if ( Triangles[ i ].p1.id >= nv || Triangles[ i ].p2.id >= nv || Triangles[ i ].p3.id >= nv)				{					Triangles.splice(i, 1);				}							}			//Remove SuperTriangle vertices			Vertex.splice(Vertex.length - 1, 1);			Vertex.splice(Vertex.length - 1, 1);			Vertex.splice(Vertex.length - 1, 1);						Triangles.concat();			return Triangles;		}		/// <summary>		/// Returns true if the point (p) lies inside the circumcircle made up by points (p1,p2,p3)		/// </summary>		/// <remarks>		/// NOTE: A point on the edge is inside the circumcircle		/// </remarks>		/// <param name="p">Point2D to check</param>		/// <param name="p1">First point on circle</param>		/// <param name="p2">Second point on circle</param>		/// <param name="p3">Third point on circle</param>		/// <returns>true if p is inside circle</returns>		private static function InCircle( p:Point2D, p1:Point2D, p2:Point2D, p3:Point2D ):Boolean		{			//Return TRUE if the point (xp,yp) lies inside the circumcircle			//made up by points (x1,y1) (x2,y2) (x3,y3)			//NOTE: A point on the edge is inside the circumcircle			var Epsilon:Number = .000000000000000000000000001;			if ( Math.abs( p1.Y - p2.Y ) < Epsilon && Math.abs( p2.Y - p3.Y) < Epsilon)			{				//INCIRCUM - F - Point2Ds are coincident !!				return false;			}			var m1:Number;			var m2:Number;			var mx1:Number;			var mx2:Number;			var my1:Number;			var my2:Number;			var xc:Number;			var yc:Number;			if ( Math.abs(p2.Y - p1.Y) < Epsilon)			{				m2 = -(p3.X - p2.X) / (p3.Y - p2.Y);				mx2 = (p2.X + p3.X) * 0.5;				my2 = (p2.Y + p3.Y) * 0.5;				//Calculate CircumCircle center (xc,yc)				xc = (p2.X + p1.X) * 0.5;				yc = m2 * (xc - mx2) + my2;			}			else if ( Math.abs(p3.Y - p2.Y) < Epsilon)			{				m1 = -(p2.X - p1.X) / (p2.Y - p1.Y);				mx1 = (p1.X + p2.X) * 0.5;				my1 = (p1.Y + p2.Y) * 0.5;				//Calculate CircumCircle center (xc,yc)				xc = (p3.X + p2.X) * 0.5;				yc = m1 * (xc - mx1) + my1;			}			else			{				m1 = -(p2.X - p1.X) / (p2.Y - p1.Y);				m2 = -(p3.X - p2.X) / (p3.Y - p2.Y);				mx1 = (p1.X + p2.X) * 0.5;				mx2 = (p2.X + p3.X) * 0.5;				my1 = (p1.Y + p2.Y) * 0.5;				my2 = (p2.Y + p3.Y) * 0.5;				//Calculate CircumCircle center (xc,yc)				xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);				yc = m1 * (xc - mx1) + my1;			}			var dx:Number = p2.X - xc;			var dy:Number = p2.Y - yc;			var rsqr:Number = dx * dx + dy * dy;			//double r = Math.Sqrt(rsqr); //Circumcircle radius			dx = p.X - xc;			dy = p.Y - yc;			var drsqr:Number = dx * dx + dy * dy;			return ( drsqr <= rsqr );		}	}}